<!DOCTYPE html>
<html>
<head lang="ja">
<meta charset="utf-8"/>
<!--
"c:\Program Files\Google\Chrome\Application\chrome.exe" --allow-file-access-from-files file:///D:/Git/ribbon/tools/webui/summary.html
-->
<!-- TODO: move to better way to build as SPA -->
<style>
ul {
	list-style-type: none;
	padding-inline-start: 0;
}
li {
  display: inline-block;
  padding: 0;
  border: 0;
  margin: 0;
}

.topic-list {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
}

.topic-list li {
}

ul.topic-word-list {
	display: flex;
	flex-direction: column;
	flex-wrap: nowrap;
	border-right: 1px solid black;
}
ul.topic-word-list li.topic-title {
	display: inline-block;
	font-size: 10px;
	font-weight: 800;
}

word-prob {
	display: inline-block;
	margin-left: 1ch;
	min-width: 20ch;
	font-size: 12px;
}

ul.phrase-list-list {
	display: flex;
	flex-direction: row;
	flex-wrap: nowrap;
}

ul.phrase-list {
	display: flex;
	flex-direction: column;
	flex-wrap: nowrap;
	border-right: 1px solid black;
}
phrase-item {
	display: inline-block;
	margin-left: 1ch;
	min-width: 20ch;
	font-size: 12px;
}
phrase-item .invalid {
	color: red;
}
phrase-item a {
	color: black;
	text-decoration: none;
}

posbigram-summary {
	font-size: 11px;
}
posbigram-summary table thead tr th {
	text-align: start;
	writing-mode: vertical-rl;
}

posbigram-summary table tbody tr td.row-head {
	text-align: left;
}

posbigram-summary button.open-close {
	padding: 0;
	border-width: 1px;
}


</style>
<script type='text/javascript' src='https://ajax.aspnetcdn.com/ajax/knockout/knockout-3.5.0.js'></script>
<script>
(() => {

function DataModel()
{
	let me = this;

	// const
	me.mixUnigramSummaryJson = "mixunigram-summary.json";
	me.topicModelSummaryJson = "topicmodel-summary.json";
	me.phraseListSummaryJson = "phrase-list-summary.json";
	me.phraseListSummaryDiffJson = "phrase-list-summary-diff.json";
	me.posBigramSummaryJson = "pos-bigram-summary.json";
	me.summaryTypeTopicModel = "topicModel";
	me.summaryTypePhraseList = "phraseList";
	me.summaryTypePosBigram = "posBigram";

	// model
	me.dataModel = ko.observable(null);
	me.summaryType = ko.observable("");
	me.generatedTime = ko.observable("");
	// topic model data
	me.tps = {
		perplexity: ko.observable("0"),
		latestPerplexity: ko.observable("0"),
		topicEntropy: ko.observable("0"),
		entropyAverage: ko.observable("0"),
	};
	me.topicModel = ko.observableArray([]);
	// phrase list data
	me.pl = {
		phraseList: ko.observableArray([]),
		katakanaPhrase: ko.observableArray([]),
		unknownPhrase: ko.observableArray([]),
		unknownWords: ko.observableArray([]),
		unknownKatakana: ko.observableArray([]),
		unknownHiragana: ko.observableArray([]),
		singleKana: ko.observableArray([]),
		unknownKanji: ko.observableArray([]),
		unknownOthers: ko.observableArray([]),
		numbers: ko.observableArray([]),
		emojis: ko.observableArray([]),
		personNames: ko.observableArray([]),
	};
	me.pb = {
		posNames: ko.observable([]),
		posBigram: ko.observableArray([]),
	}

	me.reloadJson = (jsonUrl) => {
		me.downloadJson(jsonUrl).then(dataModel => {
			if (dataModel.summaryType === me.summaryTypeTopicModel)
			{
				me.dataModel(dataModel);
				me.generatedTime(dataModel.generatedTime);
				me.tps.perplexity(dataModel.tps.perplexity.toString());
				me.tps.latestPerplexity(dataModel.tps.latestPerplexity.toString());
				me.tps.topicEntropy(dataModel.tps.topicEntropy.toString());
				me.tps.entropyAverage(dataModel.tps.entropyAverage.toString());
				me.topicModel(dataModel.topicModel);
			}
			else if (dataModel.summaryType === me.summaryTypePhraseList)
			{
				me.dataModel(dataModel);
				me.generatedTime(dataModel.generatedTime);
				me.pl.phraseList(dataModel.phraseList);
				me.pl.katakanaPhrase(dataModel.katakanaPhrase);
				me.pl.unknownPhrase(dataModel.unknownPhrase);
				me.pl.unknownWords(dataModel.unknownWords);
				me.pl.unknownKatakana(dataModel.unknownKatakana);
				me.pl.unknownHiragana(dataModel.unknownHiragana);
				me.pl.singleKana(dataModel.singleUnknown);
				me.pl.unknownKanji(dataModel.unknownKanji);
				me.pl.unknownOthers(dataModel.unknownOthers);
				me.pl.numbers(dataModel.numbers);
				me.pl.emojis(dataModel.emojis);
				me.pl.personNames(dataModel.personNames);
			}
			else if (dataModel.summaryType === me.summaryTypePosBigram)
			{
				me.dataModel(dataModel);
				me.generatedTime(dataModel.generatedTime);
				me.pb.posNames(dataModel.posOrder);
				me.pb.posBigram(dataModel.posBigram);
			}
			me.summaryType(dataModel.summaryType);
		});
	};

	me.downloadJson = function (url) {
		return new Promise((resolve, reject) => {
			let xmlHttp = new XMLHttpRequest();
			xmlHttp.onload = function() {
				let jsonResult = JSON.parse(xmlHttp.responseText);
				if (typeof jsonResult.error !== "undefined") {
					let errorCode = (typeof jsonResult.code !== "undefined") ? (jsonResult.code.toString() + ": ") : "";
					let errorText = errorCode + jsonResult.error;
					reject(errorText);
				} else {
					resolve(JSON.parse(xmlHttp.responseText));
				}
			}
			xmlHttp.onerror = function() {
				reject(xmlHttp.statusText);
			}
			xmlHttp.open("GET", url, true);
			// xmlHttp.responseType = "arraybuffer";
			xmlHttp.send();
		});
	};
}

ko.components.register("root-node", {
	template:
		'<h1>Summary Page <span data-bind="text: generatedTime"></span></h1>' + 
		'<button data-bind="click: onLoadTopicModel">TopicModel</button>' +
		'<button data-bind="click: onLoadMixUnigram">MixUnigram</button>' +
		'<button data-bind="click: onLoadPhraseList">PhraseList</button>' +
		'<button data-bind="click: onLoadPhraseDiffList">PhraseDiff</button>' +
		'<button data-bind="click: onLoadPosBigramList">PosBigram</button>' +
		'<!-- ko if: isTopicModel --><topic-model-summary params="dataModel:dataModel"></topic-model-summary><!-- /ko -->' +
		'<!-- ko if: isPhraseList --><phrase-list-summary params="dataModel:dataModel"></phrase-list-summary><!-- /ko -->' +
		'<!-- ko if: isPosBigram --><posbigram-summary params="dataModel:dataModel"></posbigram-summary><!-- /ko -->'
	,
	viewModel: function (params) {
		let me = this;
		me.dataModel = new DataModel();
		me.generatedTime = me.dataModel.generatedTime;

		me.isTopicModel = ko.pureComputed(() => (me.dataModel.summaryType() === me.dataModel.summaryTypeTopicModel));
		me.isPhraseList = ko.pureComputed(() => (me.dataModel.summaryType() === me.dataModel.summaryTypePhraseList));
		me.isPosBigram = ko.pureComputed(() => (me.dataModel.summaryType() === me.dataModel.summaryTypePosBigram));

		me.onLoadTopicModel = function () { me.dataModel.reloadJson(me.dataModel.topicModelSummaryJson); };
		me.onLoadMixUnigram = function () { me.dataModel.reloadJson(me.dataModel.mixUnigramSummaryJson); };
		me.onLoadPhraseList = function () { me.dataModel.reloadJson(me.dataModel.phraseListSummaryJson); };
		me.onLoadPhraseDiffList = function () { me.dataModel.reloadJson(me.dataModel.phraseListSummaryDiffJson); };
		me.onLoadPosBigramList = function ()  { me.dataModel.reloadJson(me.dataModel.posBigramSummaryJson); };

		me.dataModel.reloadJson(me.dataModel.topicModelSummaryJson);
	}
});

ko.components.register("topic-model-summary", {
	template:
		'<div class="topic-model-summary">' +
			'Latest Perplexity: <span data-bind="text: latestPerplexity"></span>, ' +
			'Perplexity: <span data-bind="text: perplexity"></span>, ' +
			'Topic Entropy: <span data-bind="text: topicEntropy"></span>, ' +
			'Entropy Average: <span data-bind="text: entropyAverage"></span>' +
			'<ul class="topic-list" data-bind="foreach: topicModel">' +
				'<li><topic-word-list params="wordList:$data, index:$index"></topic-word-list></li>' +
			'</ul>' +
		'</div>'
	,
	viewModel: function (params) {
		let me = this;
		me.topicModel = params.dataModel.topicModel;
		me.perplexity = params.dataModel.tps.perplexity;
		me.latestPerplexity = params.dataModel.tps.latestPerplexity;
		me.topicEntropy = params.dataModel.tps.topicEntropy;
		me.entropyAverage = params.dataModel.tps.entropyAverage;
	}
});

ko.components.register("topic-word-list", {
	template:
		'<ul class="topic-word-list">' +
			'<li class="topic-title"><span data-bind="text: title"></span></li>' +
			'<!-- ko foreach: wordList -->' +
				'<li><word-prob params="wp:$data"></word-prob></li>' +
			'<!-- /ko -->' +
		'</ul>'
	,
	viewModel: function (params) {
		let me = this;
		me.wordList = params.wordList;
		me.title = (params.index() == 0) ? "Low Entropy" :
					(params.index() == 1) ? "Low P * Entropy" :
					(params.index() == 2) ? "High Entropy" :
					(params.index() == 3) ? "High P * Entropy" :
					("Topic " + (params.index() - 3).toString());
	}
});

ko.components.register("word-prob", {
	template: '<span data-bind="text: wordText"></span>',
	viewModel: function (params) {
		let me = this;
		let wordProps = params.wp.w.split(",");
		me.wordText = wordProps[0] + "/" + wordProps[1];
	}
});

ko.components.register("phrase-list-summary", {
	template:
		'<ul class="phrase-list-list">' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Phrases</span></li>' +
					'<!-- ko foreach: phraseList -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Katakana phrases</span></li>' +
					'<!-- ko foreach: katakanaPhrase -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown phrases</span></li>' +
					'<!-- ko foreach: unknownPhrase -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown words</span></li>' +
					'<!-- ko foreach: unknownWords -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown Katakana</span></li>' +
					'<!-- ko foreach: unknownKatakana -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown Hiragana</span></li>' +
					'<!-- ko foreach: unknownHiragana -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown Kanji</span></li>' +
					'<!-- ko foreach: unknownKanji -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Single Kana</span></li>' +
					'<!-- ko foreach: singleKana -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Unknown Others</span></li>' +
					'<!-- ko foreach: unknownOthers -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Numbers</span></li>' +
					'<!-- ko foreach: numbers -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Emojis</span></li>' +
					'<!-- ko foreach: emojis -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
			'<li class="phrase-list-container">' +
				'<ul class="phrase-list">' +
					'<li class="phrase-list-title"><span>Person names</span></li>' +
					'<!-- ko foreach: personNames -->' +
						'<li><phrase-item params="ph:$data"></phrase-item></li>' +
					'<!-- /ko -->' +
				'</ul>' +
			'</li>' +
		'</ul>'
	,
	viewModel: function (params) {
		let me = this;
		me.phraseList = params.dataModel.pl.phraseList;
		me.katakanaPhrase = params.dataModel.pl.katakanaPhrase;
		me.unknownPhrase = params.dataModel.pl.unknownPhrase;
		me.unknownWords = params.dataModel.pl.unknownWords;
		me.unknownKatakana = params.dataModel.pl.unknownKatakana;
		me.unknownHiragana = params.dataModel.pl.unknownHiragana;
		me.singleKana = params.dataModel.pl.singleKana;
		me.unknownKanji = params.dataModel.pl.unknownKanji;
		me.unknownOthers = params.dataModel.pl.unknownOthers;
		me.numbers = params.dataModel.pl.numbers;
		me.emojis = params.dataModel.pl.emojis;
		me.personNames = params.dataModel.pl.personNames;
	}
});

ko.components.register("phrase-item", {
	template:
		'<a data-bind="attr: { href: url }" target="_blank">' +
			'<!-- ko foreach: words --><span data-bind="css: { invalid: isInvalid }, attr: { title: pos }, text:text"></span>/<!-- /ko --> (<span data-bind="text: count"></span>)' +
		'</a>'
	,
	viewModel: function (params) {
		let me = this;
		let reIsValid = new RegExp("\\*,\\*$|,フィラー,");
		let textOnly = "";
		me.words = params.ph.w.map(x => {
			let isInValid = (reIsValid.exec(x) != null);
			let displayText = x.split(",")[0];
			textOnly += displayText;
			return {
				pos: x,
				isInvalid: isInValid,
				text: displayText + (isInValid ? "*" : "")
			};
		});
		me.count = params.ph.c;
		let queryString = new URLSearchParams({ q: textOnly }).toString()
		me.url = "https://www.google.com/search?" + queryString;
	}
});

ko.components.register("posbigram-summary", {
	template:
		'<button data-bind="click: onCloseAll">close all</button>' +
		'<table>' +
			'<thead>' +
				'<tr>' +
					'<th>-</th>' +
					'<!-- ko foreach: $component.columnList -->' +
						'<th>' +
							'<button class="open-close" data-bind="click: $component.onClickColumn.bind($component, $data, 1)">&#x2795;</button>' +
							'<button class="open-close" data-bind="click: $component.onClickColumn.bind($component, $data, -1)">&#x2796;</button>' +
							'<span  data-bind="text: $component.GetLabel($data)"></span>' +
						'</th>' +
					'<!-- /ko -->' +
				'</tr>' +
			'</thead>' +
			'<tbody>' +
				'<!-- ko foreach: $component.rowList -->' +
					'<tr>' +
						'<td>' +
							'<button class="open-close" data-bind="click: $component.onClickRow.bind($component, $data, 1)">&#x2795;</button>' +
							'<button class="open-close" data-bind="click: $component.onClickRow.bind($component, $data, -1)">&#x2796;</button>' +
							'<span  data-bind="text: $component.GetLabel($data)"></span>' +
						'</td>' +
						'<!-- ko foreach: $component.columnList -->' +
							'<td data-bind="text: $component.GetCellValue($parent, $data), click: $component.onClickCell.bind($component, $parent, $data)"></td>' +
						'<!-- /ko -->' +
					'</tr>' +
				'<!-- /ko -->' +
			'</tbody>' +
		'</table>'
	,
	viewModel: function (params) {
		let me = this;
		me.posTree = {};
		me.posNames = params.dataModel.pb.posNames;
		me.posBigram = params.dataModel.pb.posBigram();

		me.posTree.children = new Map();
		me.posTree.isColumnOpened = ko.observable(true);
		me.posTree.isRowOpened = ko.observable(true);

		let posNames = params.dataModel.pb.posNames();
		for (let i = 0; i < posNames.length; ++i) {
			let posName = posNames[i];
			let posFields = posName.split(',');

			let parentNode = me.posTree;
			let posLongText = "";
			for (let j = 0; j < 7; ++j)
			{
				let posText = posFields[Math.min((j + 1) % 7, posFields.length - 1)];
				posLongText = (j == 0) ? posText : (posLongText + "," + posText);

				if (!parentNode.children.has(posText))
				{
					let node = {
						text: posLongText,
						indice: [],
						parent: parentNode,
						children: new Map(),
						descendCount: 0,
						isColumnOpened: ko.observable(false),
						isRowOpened: ko.observable(false),
					};
					parentNode.children.set(posText, node);
				}
				let currentNode = parentNode.children.get(posText);
				currentNode.indice.push(i);
				currentNode.descendCount++;
				parentNode = currentNode;
			}
		}

		me.columnList = ko.pureComputed(() => {
			let makeList = (node) => {
				let nodeList = [];
				for (const child of node.children.values()) {
					if (child.isColumnOpened()) {
						nodeList = nodeList.concat(makeList(child));
					}
					else
					{
						nodeList.push(child);
					}
				}
				return nodeList;
			}
			return makeList(me.posTree);
		});
		me.rowList = ko.pureComputed(() => {
			let makeList = (node) => {
				let nodeList = [];
				for (const child of node.children.values()) {
					if (child.isRowOpened()) {
						nodeList = nodeList.concat(makeList(child));
					}
					else
					{
						nodeList.push(child);
					}
				}
				return nodeList;
			}
			return makeList(me.posTree);
		});

		me.GetLabel = (posNode) => {
			return posNode.text + "(" + posNode.descendCount.toString() + ")";
		};
		me.GetCellValue = (leftPos, rightPos) => {
			let sum = 0;
			let hasConnection = false;
			let hasNoConnection = false;
			for (const x of leftPos.indice) {
				for (const y of rightPos.indice) {
					hasConnection = hasConnection || (me.posBigram[x][y] > 0);
					hasNoConnection = hasNoConnection || (me.posBigram[x][y] < 0);
				}
			}
			return (hasConnection && !hasNoConnection) ? "\uD83D\uDFE2"
					: (!hasConnection && hasNoConnection) ? "\u274C"
					: (hasConnection && hasNoConnection) ? "\u26A0\uFE0F" : "??";
		};

		me.onClickColumn = (posNode, openClose) => {
			if (openClose > 0 && posNode.descendCount > 1) {
				posNode.isColumnOpened(true);
			} else if (openClose < 0 && posNode.parent != me.posTree) {
				posNode.parent.isColumnOpened(false);
			}
		};
		me.onClickRow = (posNode, openClose) => {
			if (openClose > 0 && posNode.descendCount > 1) {
				posNode.isRowOpened(true);
			} else if (openClose < 0 && posNode.parent != me.posTree) {
				posNode.parent.isRowOpened(false);
			}
		};
		me.onClickCell = (leftNode, rightNode) => {
			if (leftNode.descendCount > 1) {
				leftNode.isRowOpened(true);
			}
			if (rightNode.descendCount > 1) {
				rightNode.isColumnOpened(true);
			}
		};
		me.onCloseAll = () => {
			let closeAllRecv = (node) => {
				for (const child of node.children.values()) {
					child.isColumnOpened(false);
					child.isRowOpened(false);
					closeAllRecv(child);
				}
			}
			closeAllRecv(me.posTree);
		};
	}
});

window.onload = function () { ko.applyBindings(); }
})();
</script>

</head>
<body>
<root-node></root-node>
</body>
</html>
